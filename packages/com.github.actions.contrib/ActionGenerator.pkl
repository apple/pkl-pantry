//===----------------------------------------------------------------------===//
// Copyright © 2025 Apple Inc. and the Pkl project authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//===----------------------------------------------------------------------===//
/// Utility library for generating a TypedStep given an action definition.
///
/// Example:
/// ```
/// import "@com.github.actions.contrib/ActionGenerator.pkl"
///
/// local generator: ActionGenerator = new { actionName = "actions/checkout@v5" }
///
/// // The resulting action's Pkl source code, in text form.
/// local generatedActionPkl = generator.result
/// ```
///
/// ## CLI usage
///
/// There is a helper to generate this action from the CLI;
/// see `generate-action.pkl`.
///
/// ## Using within a project
///
/// If generating a package within a project, the `githubActionsPackageName` property needs to be set.
/// This needs to be the simple name of the dependency that maps to package coordinate
/// `package://pkg.pkl-lang.org/pkl-pantry/com.github.actions`.
///
/// For example:
///
/// ```
/// import "@com.github.actions.contrib/ActionGenerator.pkl"
///
/// local generator: ActionGenerator = new {
///   actionName = "actions/checkout@v5"
///   githubActionsPackageName = "com.github.actions"
/// }
/// ```
@ModuleInfo { minPklVersion = "0.30.0" }
module com.github.actions.contrib.ActionGenerator

import "pkl:semver"
import "pkl:yaml"
import "@com.github.actions/Action.pkl"
import "@deepToTyped/deepToTyped.pkl"
import "@io.github.typesafegithub/ActionTypes.pkl"
import "@syntax/AnnotationNode.pkl"
import "@syntax/ClassOrModuleNode.pkl"
import "@syntax/ExpressionNode.pkl"
import "@syntax/IdentifierNode.pkl"
import "@syntax/ModuleNode.pkl"
import "@syntax/ObjectBodyNode.pkl"
import "@syntax/TypeNode.pkl"
import "util.pkl"

local comGithubActionsVerison = read("@com.github.actions/VERSION.txt").text.trim()

/// The name of the action to be generated.
///
/// Example: `"actions/checkout@v4"`
actionName: ActionName

/// The action definition to generate
///
/// If [null], will read and parse from GitHub, based on [actionName].
action: Action?

/// The specific type for each action input.
///
/// If [null], will try to read from the repo's `action-types.yml` file, or from
/// <https://github.com/typesafegithub/github-actions-typing-catalog>, based on [actionName].
actionTypes: ActionTypes?

/// Whether to discover action types, if [actionTypes] is null.
discoverActionTypes: Boolean = true

/// Any adjustments that need to be made to the generated `With` class.
adjustments: Mapping<String, Mixin<ClassOrModuleNode.PropertyDefinitionNode>>?

/// A prefix name to add to the module
moduleNamePrefix: String?

/// A path prefix to add to the module
pathPrefix: String?

/// The name of the GitHub actions package.
githubActionsPackageName: String =
  "package://pkg.pkl-lang.org/pkl-pantry/com.github.action@\(comGithubActionsVerison)#"

local actionYamlUrl =
  if (subpath == null)
    "https://raw.githubusercontent.com/\(owner)/\(repo)/refs/tags/\(version)/action.yml"
  else
    "https://raw.githubusercontent.com/\(owner)/\(repo)/refs/tags/\(version)/\(subpath)/action.yml"

local yamlParser = new yaml.Parser { useMapping = true; mode = "1.2" }

local actionYaml =
  read?(actionYamlUrl)
    ?? throw("Cannot import action.yml. Is this an action repository? Tried `\(actionYamlUrl)`")

local effectiveAction =
  action ?? deepToTyped.apply(Action.getClass(), yamlParser.parse(actionYaml)) as Action

local versionMajor = semver.parseOrNull(version.replaceFirst("v", ""))?.major
local actionTypesUrlFallbackVersion = versionMajor.ifNonNull((it) -> "v\(it)")

local actionTypesUrls: Listing<String?> = new {
  "https://raw.githubusercontent.com/\(owner)/\(repo)/refs/tags/\(version)\(subpath.ifNonNull((it) -> "/\(it)") ?? "")/action-types.yml"
  if (actionTypesUrlFallbackVersion != null)
    "https://raw.githubusercontent.com/\(owner)/\(repo)/refs/tags/\(actionTypesUrlFallbackVersion)\(subpath.ifNonNull((it) -> "/\(it)") ?? "")/action-types.yml"
  else
    null

  "https://raw.githubusercontent.com/typesafegithub/github-actions-typing-catalog/refs/heads/main/typings/\(owner)/\(repo)/\(version)\(subpath.ifNonNull((it) -> "/\(it)") ?? "")/action-types.yml"
  if (actionTypesUrlFallbackVersion != null)
    "https://raw.githubusercontent.com/typesafegithub/github-actions-typing-catalog/refs/heads/main/typings/\(owner)/\(repo)/\(actionTypesUrlFallbackVersion)\(subpath.ifNonNull((it) -> "/\(it)") ?? "")/action-types.yml"
  else
    null
}

local actionTypesUrl =
  actionTypesUrls.toList().filterNonNull().findOrNull((it) -> read?(it) != null)

local actionTypesYaml =
  actionTypesUrl.ifNonNull((it) -> read?(it))
    ?? let (
      _ =
        trace(
          """
          This action’s inputs can have its input types enhanced using an `action-types.yml` file.
          Reference: https://github.com/typesafegithub/github-actions-typing

          The file can be placed either in the repository itself or passed in when programmatically generating this action using `ActionGenerator.pkl`.
          """
        )
    )
      null

// noinspection TypeMismatch
local effectiveActionTypes: ActionTypes? =
  actionTypes
    ?? if (discoverActionTypes)
      actionTypesYaml.ifNonNull((it) ->
        let (parsed = yamlParser.parse(it) as Mapping)
          util.toActionTypes(parsed)
      )
    else
      null

local const actionNameRegex = Regex(#"([^/]+)/([^/]+)(?:/(.+))?@(v\d+(\.\d+\.\d+)?)"#)

typealias ActionName = String(matches(actionNameRegex))

local parts = actionNameRegex.findMatchesIn(actionName).first

local owner = parts.groups[1].value

local repo = parts.groups[2].value

local subpath = parts.groups[3]?.value

local version = parts.groups[4].value

fixed moduleName =
  let (name = if (subpath != null) repo + "-" + subpath.replaceAll("/", "-") else repo)
    util.pascalCase(name)

fixed inputsName = "With"

local const function DeclaredTypeNode(_name: String): TypeNode.DeclaredTypeNode = new {
  name {
    parts {
      for (part in _name.split(".")) {
        new { value = part }
      }
    }
  }
}

local const function toTypeNode(actionType: ActionTypes.Property?): TypeNode =
  if (actionType == null)
    new TypeNode.UnionTypeNode {
      members {
        DeclaredTypeNode("String")
        DeclaredTypeNode("Boolean")
        DeclaredTypeNode("Number")
      }
    }
  else if (actionType.type == "string")
    DeclaredTypeNode("String")
  else if (actionType.type == "boolean")
    DeclaredTypeNode("Boolean")
  else if (actionType.type == "integer")
    DeclaredTypeNode("Int")
  else if (actionType.type == "float")
    DeclaredTypeNode("Float")
  else if (actionType.type == "enum")
    new TypeNode.UnionTypeNode {
      members {
        for (_value in actionType.`allowed-values`!!) {
          new TypeNode.StringLiteralTypeNode {
            value = _value
          }
        }
      }
    }
  else
    (DeclaredTypeNode("Listing")) {
      typeArguments {
        toTypeNode(actionType.`list-item`!!)
      }
    }

local const pcfRenderer = new PcfRenderer {}

local class InputProperty {
  local self = this

  name: String

  input: Action.Input

  inputType: ActionTypes.Property?

  adjustments: Mapping<String, Mixin<ClassOrModuleNode.PropertyDefinitionNode>>?

  // assertion: an input is not truly required if there is a default value.
  fixed isRequired = input.required == true && input.default == null

  effectiveInputName: String =
    if (inputType?.type == "list")
      // mirror the casing style of these properties
      if (self.name.contains("-"))
        "\(self.name)-list"
      else if (self.name.contains("_"))
        "\(self.name)_list"
      else
        "\(self.name)List"
    else
      self.name

  fixed docCommentValue =
    if (input.default != null)
      """
      \(input.description.trim())

      Default if unspecified: `\(pcfRenderer.renderValue(input.default))`
      """
    else
      input.description.trim()

  local deprecation: AnnotationNode = new {
    identifier {
      parts {
        new { value = "Deprecated" }
      }
    }
    body {
      members {
        new ObjectBodyNode.PropertyMemberNode {
          propertyName {
            value = "message"
          }
          assignment = new ExpressionNode.LiteralValueExpressionNode {
            value = input.deprecationMessage!!.trim()
          }
        }
      }
    }
  }

  fixed _propertyNode: ClassOrModuleNode.PropertyDefinitionNode = new {
    name {
      value = effectiveInputName
    }
    when (inputType?.type == "list") {
      modifiers {
        "hidden"
      }
    }
    docComment {
      value = docCommentValue
    }
    when (input.deprecationMessage != null) {
      annotations {
        deprecation
      }
    }
    typeAnnotation {
      local baseType = toTypeNode(inputType)
      type =
        if (isRequired)
          baseType
        else
          new TypeNode.NullableTypeNode { typeNode = baseType }
    }
  }

  fixed propertyNode =
    let (adjustment = adjustments?.getOrNull(effectiveInputName))
      if (adjustment != null)
        _propertyNode |> adjustment
      else
        _propertyNode

  fixed _outputPropertyNode: ClassOrModuleNode.PropertyDefinitionNode? =
    if (inputType?.type == "list")
      new {
        name {
          value = self.name
        }
        docComment {
          local ident: IdentifierNode = new { value = self.effectiveInputName }
          value =
            """
            \(docCommentValue)

            To set as a [Listing], use [\(ident.render(""))].
            """
        }
        when (input.deprecationMessage != null) {
          annotations {
            deprecation
          }
        }
        typeAnnotation {
          local baseType = DeclaredTypeNode("String")
          type =
            if (isRequired)
              baseType
            else
              new TypeNode.NullableTypeNode { typeNode = baseType }
        }
        defaultValue = new ExpressionNode.QualifiedMemberAccessExpressionNode {
          lhs = new ExpressionNode.MemberAccessExpressionNode {
            identifier {
              value = "\(self.effectiveInputName)"
            }
          }
          symbol = if (isRequired) "." else "?."
          rhs {
            identifier {
              value = "join"
            }
            arguments {
              new ExpressionNode.StringExpressionNode {
                stringParts {
                  inputType.separator!!
                }
              }
            }
          }
        }
      }
    else
      null

  fixed outputPropertyNode: ClassOrModuleNode.PropertyDefinitionNode? =
    if (_outputPropertyNode == null)
      null
    else
      let (adjustment = adjustments?.getOrNull(self.name))
        if (adjustment != null)
          _outputPropertyNode |> adjustment
        else
          _outputPropertyNode
}

local inputs: Listing<InputProperty> = new {
  for (propName, actionInput in effectiveAction.inputs!!) {
    new {
      name = propName
      input = actionInput
      inputType =
        if (effectiveActionTypes != null)
          if (effectiveActionTypes.inputs?.containsKey(propName) == false)
            let (
              _ = trace("Incomplete action types: missing type for \(propName) for \(actionName)")
            )
              null
          else
            effectiveActionTypes.inputs!![propName]
        else
          null
      adjustments = module.adjustments
    }
  }
}

fixed modulePath: Listing<String> = new {
  owner
  repo
  when (subpath != null) {
    ...subpath.split("/")
  }
  version
}

fixed moduleNode: ModuleNode = new {
  declaration {
    docComment {
      value = effectiveAction.description
    }
    moduleHeader {
      name {
        parts {
          when (moduleNamePrefix != null && !moduleNamePrefix.isEmpty) {
            ...moduleNamePrefix.split(".").map((it) -> new IdentifierNode { value = it })
          }
          for (path in modulePath) {
            new { value = path }
          }
          new { value = moduleName }
        }
      }
      moduleExtendsOrAmendsClause {
        type = "extends"
        extendedModule = "\(githubActionsPackageName)/AbstractTypedStep.pkl"
      }
    }
  }
  properties {
    new {
      name {
        value = "action"
      }
      modifiers {
        "fixed"
      }
      typeAnnotation {
        type = new TypeNode.StringLiteralTypeNode {
          value = if (subpath == null) "\(owner)/\(repo)" else "\(owner)/\(repo)/\(subpath)"
        }
      }
    }
    new {
      name {
        value = "version"
      }
      modifiers {
        "fixed"
      }
      typeAnnotation {
        type = new TypeNode.StringLiteralTypeNode { value = version }
      }
    }
    new {
      name {
        value = "with"
      }
      typeAnnotation {
        type = new TypeNode.DeclaredTypeNode {
          name {
            parts {
              new { value = inputsName }
            }
          }
        }
      }
    }
  }
  classes {
    new {
      classHeader {
        name {
          value = inputsName
        }
      }
      properties {
        for (input in inputs) {
          input.propertyNode
          when (input.outputPropertyNode != null) {
            input.outputPropertyNode!!
          }
        }
      }
    }
  }
}

/// The resulting Pkl code from generating this action.
fixed result = moduleNode.output.text
