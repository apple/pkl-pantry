//===----------------------------------------------------------------------===//
// Copyright Â© 2025 Apple Inc. and the Pkl project authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//===----------------------------------------------------------------------===//
/// Generates a typesafe action.
///
/// This converter relies on action types as defined by [typesafegithub](https://github.com/typesafegithub),
/// and will look either at the repo's `action-types.yml` file, or within
/// [github-actions-typing-catalog](https://github.com/typesafegithub/github-actions-typing-catalog) to determine the
/// corresponding types.
///
/// Sample usage:
///
///     pkl eval package://pkg.pkl-lang.org/pkl-pantry/com.github.actions.contrib@<VERSION>#/generate-action.pkl \
///       -m . \
///       -p action-name=actions/checkout@v4
@ModuleInfo { minPklVersion = "0.30.0" }
module com.github.actions.contrib.`generate-action`

import "pkl:yaml"

import "@com.github.actions/Action.pkl"
import "@deepToTyped/deepToTyped.pkl"
import "@io.github.typesafegithub/ActionTypes.pkl"
import "@syntax/AnnotationNode.pkl"
import "@syntax/ClassOrModuleNode.pkl"
import "@syntax/ExpressionNode.pkl"
import "@syntax/IdentifierNode.pkl"
import "@syntax/ModuleNode.pkl"
import "@syntax/ObjectBodyNode.pkl"
import "@syntax/TypeNode.pkl"

import "util.pkl"

/// The name of the action that should be generated.
///
/// Should include the version string.
actionName: ActionName = read("prop:action-name")

/// Any adjustments that need to be made to the generated `With` class.
adjustments: Mapping<String, Mixin<ClassOrModuleNode.PropertyDefinitionNode>>?

moduleNamePrefix: String = ""

abstractTypedStepModule: String?

local const actionNameRegex = Regex(#"([^/]+)/([^/]+)(?:/(.+))?@(v\d+)"#)

typealias ActionName = String(matches(actionNameRegex))

local parts = actionNameRegex.findMatchesIn(actionName).first

local owner = parts.groups[1].value

local repo = parts.groups[2].value

local subpath = parts.groups[3]?.value

local version = parts.groups[4].value

local actionYamlUrl =
  if (subpath == null)
    "https://raw.githubusercontent.com/\(owner)/\(repo)/refs/tags/\(version)/action.yml"
  else
    "https://raw.githubusercontent.com/\(owner)/\(repo)/refs/tags/\(version)/\(subpath)/action.yml"

local yamlParser = new yaml.Parser { useMapping = true; mode = "1.2" }

local actionYaml =
  read?(actionYamlUrl)
    ?? throw("Cannot import action.yml. Is this an action repository? Tried `\(actionYamlUrl)`")

local action = deepToTyped.apply(Action.getClass(), yamlParser.parse(actionYaml)) as Action

local actionTypesUrl1 =
  if (subpath == null)
    "https://raw.githubusercontent.com/\(owner)/\(repo)/refs/tags/\(version)/action-types.yml"
  else
    "https://raw.githubusercontent.com/\(owner)/\(repo)/refs/tags/\(version)/\(subpath)/action-types.yml"

local actionTypesUrl2 =
  if (subpath == null)
    "https://raw.githubusercontent.com/typesafegithub/github-actions-typing-catalog/refs/heads/main/typings/\(owner)/\(repo)/\(version)/action-types.yml"
  else
    "https://raw.githubusercontent.com/typesafegithub/github-actions-typing-catalog/refs/heads/main/typings/\(owner)/\(repo)/\(version)/\(subpath)/action-types.yml"

local actionTypesYaml =
  read?(actionTypesUrl1)
    ?? read?(actionTypesUrl2)
    ?? throw(
      """
      Unable to find action-types.yml for this action.
      Unfortunately, I cannot generate the Pkl module.
      This action will need to be hand-authored by looking at its README to determine the correct input types.

      Tried:
      * \(actionTypesUrl1)
      * \(actionTypesUrl2)
      """
    )

fixed actionTypes: ActionTypes =
  let (parsed = yamlParser.parse(actionTypesYaml) as Mapping)
    util.toActionTypes(parsed)

local moduleName = util.pascalCase(repo)

local inputsName = "With"

local const function DeclaredTypeNode(_name: String): TypeNode.DeclaredTypeNode = new {
  name {
    parts {
      for (part in _name.split(".")) {
        new { value = part }
      }
    }
  }
}

local const function toTypeNode(actionType: ActionTypes.Property): TypeNode =
  if (actionType.type == "string")
    DeclaredTypeNode("String")
  else if (actionType.type == "boolean")
    DeclaredTypeNode("Boolean")
  else if (actionType.type == "integer")
    DeclaredTypeNode("Int")
  else if (actionType.type == "float")
    DeclaredTypeNode("Float")
  else if (actionType is ActionTypes.EnumProperty)
    new TypeNode.UnionTypeNode {
      members {
        for (_value in actionType.`allowed-values`) {
          new TypeNode.StringLiteralTypeNode {
            value = _value
          }
        }
      }
    }
  else
    (DeclaredTypeNode("Listing")) {
      typeArguments {
        local node = actionType as ActionTypes.ListProperty
        // noinspection TypeMismatch
        toTypeNode(node.`list-item`)
      }
    }

local const pcfRenderer = new PcfRenderer {}

class InputProperty {
  local self = this

  name: String

  input: Action.Input

  inputType: ActionTypes.Property

  adjustments: Mapping<String, Mixin<ClassOrModuleNode.PropertyDefinitionNode>>?

  // assertion: an input is not truly required if there is a default value.
  fixed isRequired = input.required == true && input.default == null

  effectiveInputName: String =
    if (inputType is ActionTypes.ListProperty)
      // mirror the casing style of these properties
      if (self.name.contains("-"))
        "\(self.name)-list"
      else if (self.name.contains("_"))
        "\(self.name)_list"
      else
        "\(self.name)List"
    else
      self.name

  fixed docCommentValue =
    if (input.default != null)
      """
      \(input.description.trim())

      Default if unspecified: `\(pcfRenderer.renderValue(input.default))`
      """
    else
      input.description.trim()

  local deprecation: AnnotationNode = new {
    identifier {
      parts {
        new { value = "Deprecated" }
      }
    }
    body {
      members {
        new ObjectBodyNode.PropertyMemberNode {
          propertyName {
            value = "message"
          }
          assignment = new ExpressionNode.LiteralValueExpressionNode {
            value = input.deprecationMessage!!
          }
        }
      }
    }
  }

  fixed _propertyNode: ClassOrModuleNode.PropertyDefinitionNode = new {
    name {
      value = effectiveInputName
    }
    when (inputType is ActionTypes.ListProperty) {
      modifiers {
        "hidden"
      }
    }
    docComment {
      value = docCommentValue
    }
    when (input.deprecationMessage != null) {
      annotations {
        deprecation
      }
    }
    typeAnnotation {
      local baseType = toTypeNode(inputType)
      type =
        if (isRequired)
          baseType
        else
          new TypeNode.NullableTypeNode { typeNode = baseType }
    }
  }

  fixed propertyNode =
    let (adjustment = adjustments?.getOrNull(effectiveInputName))
      if (adjustment != null)
        _propertyNode |> adjustment
      else
        _propertyNode

  fixed _outputPropertyNode: ClassOrModuleNode.PropertyDefinitionNode? =
    if (inputType is ActionTypes.ListProperty)
      new {
        name {
          value = self.name
        }
        docComment {
          local ident: IdentifierNode = new { value = self.effectiveInputName }
          value =
            """
            \(docCommentValue)

            To set as a [Listing], use [\(ident.render(""))].
            """
        }
        when (input.deprecationMessage != null) {
          annotations {
            deprecation
          }
        }
        typeAnnotation {
          local baseType = DeclaredTypeNode("String")
          type =
            if (isRequired)
              baseType
            else
              new TypeNode.NullableTypeNode { typeNode = baseType }
        }
        defaultValue = new ExpressionNode.QualifiedMemberAccessExpressionNode {
          lhs = new ExpressionNode.MemberAccessExpressionNode {
            identifier {
              value = "\(self.effectiveInputName)"
            }
          }
          symbol = if (isRequired) "." else "?."
          rhs {
            identifier {
              value = "join"
            }
            arguments {
              new ExpressionNode.StringExpressionNode {
                stringParts {
                  inputType.separator
                }
              }
            }
          }
        }
      }
    else
      null

  fixed outputPropertyNode: ClassOrModuleNode.PropertyDefinitionNode? =
    if (_outputPropertyNode == null)
      null
    else
      let (adjustment = adjustments?.getOrNull(self.name))
        if (adjustment != null)
          _outputPropertyNode |> adjustment
        else
          _outputPropertyNode
}

local inputs: Listing<InputProperty> = new {
  for (propName, actionInput in action.inputs!!) {
    new {
      name = propName
      input = actionInput
      inputType = actionTypes.inputs!![propName]
      adjustments = module.adjustments
    }
  }
}

local modulePath: Listing<String> = new {
  owner
  repo
  when (subpath != null) {
    ...subpath.split("/")
  }
  version
}

fixed moduleNode: ModuleNode = new {
  declaration {
    docComment {
      value = action.description
    }
    moduleHeader {
      name {
        parts {
          ...moduleNamePrefix.split(".").map((it) -> new IdentifierNode { value = it })
          for (path in modulePath) {
            new { value = path }
          }
          new { value = moduleName }
        }
      }
      moduleExtendsOrAmendsClause {
        type = "extends"
        extendedModule = abstractTypedStepModule ?? "@com.github.actions/AbstractTypedStep.pkl"
      }
    }
  }
  properties {
    new {
      name {
        value = "action"
      }
      modifiers {
        "fixed"
      }
      typeAnnotation {
        type = new TypeNode.StringLiteralTypeNode {
          value = if (subpath == null) "\(owner)/\(repo)" else "\(owner)/\(repo)/\(subpath)"
        }
      }
    }
    new {
      name {
        value = "version"
      }
      modifiers {
        "fixed"
      }
      typeAnnotation {
        type = new TypeNode.StringLiteralTypeNode { value = version }
      }
    }
    new {
      name {
        value = "with"
      }
      typeAnnotation {
        type = new TypeNode.DeclaredTypeNode {
          name {
            parts {
              new { value = inputsName }
            }
          }
        }
      }
    }
  }
  classes {
    new {
      classHeader {
        name {
          value = inputsName
        }
      }
      properties {
        for (input in inputs) {
          input.propertyNode
          when (input.outputPropertyNode != null) {
            input.outputPropertyNode!!
          }
        }
      }
    }
  }
}

output {
  text = throw("I must be called using the `-m` flag.")
  files {
    ["\(modulePath.join("/"))/\(moduleName).pkl"] = moduleNode.output
  }
}
