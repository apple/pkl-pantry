//===----------------------------------------------------------------------===//
// Copyright Â© 2024 Apple Inc. and the Pkl project authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//===----------------------------------------------------------------------===//
module org.openapis.v3.OpenAPI

import "Components.pkl"
import "Info.pkl"
import "OpenAPI.pkl"
import "PathItem.pkl"
import "Reference.pkl"
import "Server.pkl"
import "Security.pkl"
import "Tag.pkl"
import "ExternalDocs.pkl"

/// A document that defines or describes an API.
///
/// An OpenAPI definition uses and conforms to the OpenAPI Specification.
open class Document {

  /// This string MUST be the semantic version number of the OpenAPI Specification version that the OpenAPI document
  /// uses.
  ///
  /// The openapi field SHOULD be used by tooling specifications and clients to interpret the OpenAPI document. This is
  /// not related to the API info.version string. The default value corresponds to the version of the spec we've
  /// implemented in this package.
  ///
  /// Since this library specifically follows version 3.0.3 of the OpenAPI spec, this value cannot change unless this
  /// library is updated to implement a later version.
  fixed openapi = "3.0.3"

  /// Provides metadata about the API.
  ///
  /// The metadata MAY be used by tooling as required.
  info: Info

  /// An array of Server Objects, which provide connectivity information to a target server.
  ///
  /// If the servers property is not provided, or is an empty array, the default value would be a Server Object with a
  /// url value of /.
  servers: Listing<Server>?

  /// The available paths and operations for the API.
  ///
  /// Contains relative paths to an individual endpoint. The field name MUST begin with a forward slash (/). The path is
  /// appended (no relative URL resolution) to the expanded URL from the Server Object's url field in order to construct
  /// the full URL. Path templating is allowed.
  ///
  /// When matching URLs, concrete (non-templated) paths would be matched before their templated counterparts.
  /// Templated paths with the same hierarchy but different templated names MUST NOT exist as they are identical.
  ///
  /// In case of ambiguous matching, it's up to the tooling to decide which one to use.
  paths: Mapping<String(startsWith("/")), PathItem>

  /// An element to hold various schemas for the specification.
  components: Components?

  /// A declaration of which security mechanisms can be used across the API.
  ///
  /// The list of values includes alternative security requirement objects that can be used. Only one of the security
  /// requirement objects need to be satisfied to authorize a request. Individual operations can override this
  /// definition. To make security optional, an empty security requirement ({}) can be included in the array.
  security: Listing<Security.Requirement>?

  /// A list of tags used by the specification with additional metadata.
  ///
  /// The order of the tags can be used to reflect on their order by the parsing tools. Not all tags that are used by
  /// the Operation Object must be declared. The tags that are not declared MAY be organized randomly or based on the
  /// tools' logic. Each tag name in the list MUST be unique.
  tags: Listing<Tag>(isDistinct)?

  /// Additional external documentation.
  externalDocs: ExternalDocs?
}

/// A set of OpenAPI documents.
typealias Documents = Listing<Document>

/// A string that complies with the OpenAPI expression grammar.
typealias Expression = String((it) ->
    if (List("$url", "$method", "$statusCode").contains(it))
      true
    else if (it.startsWith("$request."))
      let (src = it.substring(9, it.length))
        OpenAPI.expSourceConstraint.apply(src)
    else if (it.startsWith("$response."))
      let (src = it.substring(10, it.length))
        OpenAPI.expSourceConstraint.apply(src)
    else
      false)

// source = ( header-reference / query-reference / path-reference / body-reference )
hidden expSourceConstraint = (it) ->
    // header-reference = "header." token
    if (it.startsWith("header."))
      let (token = it.substring(7, it.length))
        OpenAPI.expTokenConstraint.apply(token)
    // query-reference = "query." name
    else if (it.startsWith("query."))
      let (name = it.substring(6, it.length))
        OpenAPI.expJSONNameConstraint.apply(name)
    // path-reference = "path." name
    else if (it.startsWith("path."))
      let (name = it.substring(5, it.length))
        OpenAPI.expJSONNameConstraint.apply(name)
    // body-reference = "body" ["#" json-pointer ]
    else if (it.startsWith("body"))
      let (suffix = it.substring(4, it.length))
        if (suffix == "")
          true
        else
          OpenAPI.expBodyReferenceConstraint.apply(suffix)
    else
      false

// token = 1*tchar
// tchar = "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "." /
//   "^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA
hidden expTokenConstraint = (it) -> it.matches(Regex(#"[0-9A-z!#$%&'+\-\.\^_\`|~]+"#))

//   unescaped       = %x00-2E / %x30-7D / %x7F-10FFFF
//      ; %x2F ('/') and %x7E ('~') are excluded from 'unescaped'
hidden expIsUnescapedCodePoint = (it) -> (it >= 0x00 && it <= 0x2E)
    || (it >= 0x30 && it <= 0x7D)
    || (it >= 0x7F && it <= 0x10FFFF)

//   escaped         = "~" ( "0" / "1" )
//     ; representing '~' and '/', respectively

// body-reference = "body" ["#" json-pointer ]
hidden expBodyReferenceConstraint = (it) ->
    if (it.startsWith("#"))
      let (suffix = it.substring(1, it.length))
        OpenAPI.expJSONPointerConstraint.apply(suffix)
    else
      false

// json-pointer = *( "/" reference-token )
hidden expJSONPointerConstraint = (it) ->
    if (it.length == 0)
      true
    else if (it.startsWith("/"))
      let (suffix = it.substring(1, it.length))
        if (suffix.indexOfOrNull("/") != null)
          let (pre = suffix.substring(0, suffix.indexOf("/")))
            let (post = suffix.substring(suffix.indexOf("/"), suffix.length))
              OpenAPI.expReferenceTokenConstraint.apply(pre)
                && OpenAPI.expJSONPointerConstraint.apply(post)
        else
          OpenAPI.expReferenceTokenConstraint.apply(suffix)
    else
      false

// reference-token = *( unescaped / escaped )
hidden expReferenceTokenConstraint = (it) ->
  it.codePoints.fold(Pair(true, false), (acc, c) ->
    Pair(
      acc.first && if (acc.second)
          (c == 0x60 || c == 0x61) // escaped values
        else
          (c == 0x7E || OpenAPI.expIsUnescapedCodePoint.apply(c)), // unescaped values
      !acc.second && c == 0x7E // only escape if we're not already escaped
    )).first

// JSON string spec: https://datatracker.ietf.org/doc/html/rfc7159#section-7
//
// NOTE: we don't need to match %x75 separately, because all we're doing here
// is validating that the input is correct. Hex digits should be okay
// regardless of whether they're escaped.
hidden expJSONNameConstraint = (it) ->
    it.length > 0 && it.codePoints.fold(Pair(true, false), (acc, c) ->
        Pair(
          acc.first &&
            if (acc.second)
              List(0x22, 0x5C, 0x2F, 0x62, 0x66, 0x6E, 0x72, 0x74, 0x75).contains(c) // escaped values
            else
              c == 0x5C || (c == 0x20 || c == 0x21 || (c >= 0x23 && c <= 0x5B) || (c >= 0x5D && c <= 0x10FFFF)), // unescaped values
          !acc.second && c == 0x5C // only escape if we're not already escaped
        )).first

/// Component reference helper function. This reference will point to the named component in the local document's
/// "components" fields.
function componentRef(type: Components.ComponentType, name: String): Reference =
  // TODO: can we throw an error if the referenced component does not exist? This would be extremely useful.
  // We may need to check for reference consistencey in the render step.
  new Reference {
    `$ref` = "#/components/\(type)/\(name)"
  }
