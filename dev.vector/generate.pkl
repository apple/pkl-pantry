//===----------------------------------------------------------------------===//
// Copyright Â© 2024 Apple Inc. and the Pkl project authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//===----------------------------------------------------------------------===//
module dev.vector

import "pkl:platform"
import "@deepToTyped/deepToTyped.pkl"
import "@jsonschema/JsonSchema.pkl"
import "@uri/URI.pkl"
import "@jsonschemagen/internal/ModulesGenerator.pkl"

import "pkl:json"

local jsonParser = new json.Parser { useMapping = true }

local sourceProperty = read("prop:source")
local sourceUri =
  if (sourceProperty.startsWith(Regex(#"\w+:"#))) sourceProperty      // absolute URI
  else if (sourceProperty.startsWith("/")) "file://\(sourceProperty)" // absolute file path
  else                                                // relative file path
    let (pwd = read("env:PWD"))
      let (path =
        if (platform.current.operatingSystem.name == "Windows") "/\(pwd)/\(sourceProperty)".replaceAll("\\", "/")
        else "\(pwd)/\(sourceProperty)"
      )
        "file://\(URI.encode(path))"

local src = read(URI.encode(sourceUri))

local jsonParsed = jsonParser.parse(src) as Mapping|Boolean

local baseSchema: JsonSchema = deepToTyped.apply(JsonSchema.Schema, jsonParsed) as JsonSchema.Schema

function mergeSchemas(baseSchema: JsonSchema, rest: List<JsonSchema.Schema>) =
  rest
    .fold(baseSchema, (aggregate: JsonSchema, schema: JsonSchema.Schema) ->
      if (schema is Boolean)
        aggregate
      else
        ((aggregate) {
          properties {
            ...schema.properties.toMap()
          }).toTyped(schema.properties.getClass())
        }.toMap() + (schema) {
            properties = null
          }.toMap().filter((_, v) -> v != null)).toTyped(baseSchema.getClass())
    )

function resolveRef(path: String): JsonSchema? =
  if (path.startsWith("#/definitions/"))
    baseSchema.definitions[path.replaceFirst("#/definitions/", "")]
  else null

function hydrateListing(listing: Listing<JsonSchema>): Listing<JsonSchema> = new {
  for (s in listing) {
      hydrateSchema(s)
    }
  }

function hydrateMapping(mapping: Mapping<String, JsonSchema>): Mapping<String, JsonSchema> = (mapping) {
  for (k, s in mapping) {
    [k] = hydrateSchema(s)
    }
  }

function hydrateSchema(schema: JsonSchema): JsonSchema =
  if (schema.$ref != null)
    hydrateSchema(
      ((resolveRef(schema.$ref).toMap().filter((_, value) -> value != null) +
        schema.toMap()).toTyped(schema.getClass())) {
        $ref = null
      }
    )
  else if (schema.allOf != null)
    hydrateSchema(
      (mergeSchemas(schema, hydrateListing(schema.allOf).toList())) {
        allOf = null
      }
    )
  else
  (schema) {
  when (schema.properties != null) {
    properties = hydrateMapping(schema.properties)
  }
  when (schema.definitions != null) {
    definitions = hydrateMapping(schema.definitions)
  }
//   when (schema.allOf != null) {
//     allOf = let (schemas = hydrateListing(schema.allOf).toList())
//       mergeSchemas(schemas.first, schemas.rest)
//   }
  when (schema.oneOf != null) {
    oneOf = hydrateListing(schema.oneOf)
  }
  when (schema.anyOf != null) {
    anyOf = hydrateListing(schema.anyOf)
  }
  when (schema.items != null) {
    when (schema.items is JsonSchema.Schema) {
      items = hydrateSchema(schema.items as JsonSchema)
    }
    when (schema.items is Listing<JsonSchema.Schema>) {
      items = hydrateListing(schema.items as Listing<JsonSchema>)
    }
  }
  when (schema.additionalProperties != null) {
    additionalProperties = hydrateSchema(schema.additionalProperties)
  }
  when (schema.additionalItems != null) {
    additionalItems = hydrateSchema(schema.additionalItems)
  }
}

local modulesGenerator = new ModulesGenerator {
  rootSchema = hydrateSchema(baseSchema)
  baseUri = URI.parse(sourceUri)!!
}

output {
  value = hydrateSchema(baseSchema)
}

// output {
//   text = throw("The JSON Schema generator only works with multiple-file output. Try running again with the -m option.")
//   files {
//     for (mod in modulesGenerator.modules) {
//       ["\(mod.moduleName).pkl"] = mod.moduleNode.output
//     }
//   }
// }